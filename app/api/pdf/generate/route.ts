// app/api/pdf/generate/route.ts
import { NextResponse } from "next/server";
import PDFDocument from "pdfkit";
import { connectDB } from "@/lib/db";
import Order from "@/lib/models/Order";
import Customer from "@/lib/models/Customer";

/**
 * Generates a basic PDF for the order and returns it as application/pdf.
 * Expects JSON body: { orderId: string, type?: 'admin'|'tailor'|'customer' }
 */
export async function POST(req: Request) {
  try {
    await connectDB();

    const { orderId, type = "customer" } = await req.json();

    if (!orderId) {
      return NextResponse.json({ error: "orderId required" }, { status: 400 });
    }

    const order = await Order.findById(orderId).populate("customerId assignedTailor").lean();
    if (!order) return NextResponse.json({ error: "Order not found" }, { status: 404 });

    const customer = order.customerId as any;

    // Create PDF in memory
    const doc = new PDFDocument({ size: "A4", margin: 50 });
    const chunks: Uint8Array[] = [];

    doc.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    const endPromise = new Promise<Buffer>((resolve, reject) => {
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      doc.on("error", (err) => reject(err));
    });

    // Header
    doc.fontSize(20).text("TailorPro", { align: "center" });
    doc.moveDown(0.5);
    doc.fontSize(12).text(`Order ID: ${order._id}`);
    doc.text(`Garment: ${order.garmentType}`);
    doc.text(`Status: ${order.status}`);
    doc.text(`Deadline: ${order.deadline || "N/A"}`);
    doc.moveDown();

    // Customer (only include for admin/customer copies)
    if (type === "admin" || type === "customer") {
      doc.fontSize(14).text("Customer Details", { underline: true });
      doc.moveDown(0.2);
      doc.fontSize(11).text(`Name: ${customer?.name || "N/A"}`);
      doc.text(`Phone: ${customer?.phone || "N/A"}`);
      doc.text(`Address: ${(customer && customer.address) || "N/A"}`);
      doc.moveDown();
    }

    // Measurements
    doc.fontSize(14).text("Measurements", { underline: true });
    doc.moveDown(0.2);
    doc.fontSize(11);
    const measurements = order.measurements || {};
    if (typeof measurements === "object" && Object.keys(measurements).length) {
      for (const [k, v] of Object.entries(measurements)) {
        doc.text(`${k}: ${JSON.stringify(v)}`);
      }
    } else {
      doc.text("No measurements found.");
    }
    doc.moveDown();

    // Billing (only for admin/customer)
    if (type === "admin" || type === "customer") {
      doc.fontSize(14).text("Billing", { underline: true });
      doc.moveDown(0.2);
      const bill = order.billing || {};
      doc.fontSize(11).text(`Amount: ${bill.amount ?? "N/A"}`);
      doc.text(`Advance: ${bill.advance ?? 0}`);
      doc.text(`Balance: ${bill.balance ?? 0}`);
      doc.moveDown();
    }

    // Tailor instructions (tailor copy)
    if (type === "tailor") {
      doc.fontSize(14).text("Tailor Instructions", { underline: true });
      doc.moveDown(0.2);
      doc.fontSize(11).text("Follow measurements exactly. No billing info included.");
      if (order.assignedTailor) {
        doc.moveDown();
        doc.text(`Assigned Tailor: ${(order.assignedTailor as any)?.name || "N/A"}`);
      }
    }

    doc.moveDown(2);
    doc.fontSize(10).text("Generated by TailorPro", { align: "center", opacity: 0.6 });

    doc.end();
    const pdfBuffer = await endPromise;

    return new NextResponse(pdfBuffer, {
      status: 200,
      headers: {
        "Content-Type": "application/pdf",
        "Content-Length": String(pdfBuffer.length),
        "Content-Disposition": `attachment; filename="order-${order._id}.pdf"`,
      },
    });
  } catch (err) {
    console.error("PDF generate error:", err);
    return NextResponse.json({ error: "Server error generating PDF" }, { status: 500 });
  }
}
